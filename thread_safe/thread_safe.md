# 线程安全的对象生命期管理

前置：
在学习本章前，读者应该了解以下知识点：
* C++ 多线程编程经验
* 熟悉互斥器
* 竞态条件
* 智能指针
* Observer设计模式

前三个通过复习生产者消费者模式。了解竞态条件：程序运行顺序影响最终结果，换句话说，多线程对同一资源的争用顺序导致结果不同。race condition
了解RAII和智能指针。
学习observer设计模式。
以上均有示例，复习后学习本章。

## 当构造遇到多线程
想象一种场景：
在一个对象的构造过程中，另一个对象使用了该对象的成员，发生了竞态。
似乎并不可能？
当你在构造函数中，注册回调函数或是将this传给跨线程的对象时，这样的情况就发生了。即使你将注册写到最后一行也同样如此，如果你的class是base class，在构造函数的最后一行后，会进行derived class的构造，在这期间对象的成员被使用，会发生什么只有天知道。

解决方案也异常简单，将注册函数或this指针传递放到单独的函数中问题便解决了。

## 当析构函数遇到多线程
多线程下，对象的析构和对象的成员函数发生竞态。

对比使用构造函数的方法，将解除竞态的操作放到单独的一个函数中，之后执行析构。
似乎很合理，然而你没法保证客户会这样操作，而且这种方法只能解除这种耦合的关系，如果另一个线程不通过其他对象调用成员函数，而是使用此对象的函数，后果便难以想象。
